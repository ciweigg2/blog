title: 【Mysql优化】MySQL中EXPLAIN执行计划分析
date: 2019-08-04 14:01:26
tags: [mysql]
categories: [mysql]
---
### 一. 执行计划能告诉我们什么？

* SQL如何使用索引

* 联接查询的执行顺序

* 查询扫描的数据函数

<!--more-->

### 二. 执行计划中的内容

![](/images/1195739-20190107174444126-1487820042.png)

SQL执行计划的输出可能为多行，每一行代表对一个数据库对象的操作

#### ID列

* ID列中的如果数据为一组数字，表示执行SELECT语句的顺序；如果为NULL，则说明这一行数据是由另外两个SQL语句进行 UNION操作后产生的结果集

* ID值相同时，说明SQL执行顺序是按照显示的从上至下执行的

* ID值不同时，ID值越大代表优先级越高，则越先被执行

演示

![](/images/1195739-20190107175806520-1858548796.png)

可以看到上面的执行计划返回了3行结果，id列的值可以看作是SQL中所具有的SELECT操作的序号

由于上述SQL中只有一个SELECT，所以id全为1，因此，我们就要按照由上至下读取执行计划

按照我们的SQL语句，我们会认为执行顺序是a,b,c,但是通过上图可以发现，Mysql并不是完成按照SQL中所写的顺序来进行表的关联操作的

执行对表的执行顺序为a,c,b，这是由于MySQL优化器会根据表中的索引的统计信息来调整表关联的实际顺序

#### SELECT_TYPE列

值 | 含义
-|-|
SIMPLE	| 不包含子查询或是UNION操作的查询
PRIMARY	| 查询中如果包含任何子查询，那么最外层的查询则被标记为PRIMARY
SUBQUERY | SELECT 列表中的子查询
DEPENDENT SUBQUERY | 依赖外部结果的子查询
UNION | Union操作的第二个或是之后的查询的值为union
DEPENDENT UNION | 当UNION作为子查询时，第二或是第二个后的查询的select_type值
UNION RESULT | UNION产生的结果集
DERIVED | 出现在FROM子句中的子查询

#### TABLE列

包含以下几种结果：

```
输出去数据行所在表的名称，如果表取了别名，则显示的是别名
<union M,N>： 由ID为M,N查询union产生的结果集
<derived N>/<subquery N> ：由ID为N的查询产生的结果
```

#### PARTITIONS列

```
查询匹配的记录来自哪一个分区
对于分区表，显示查询的分区ID
对于非分区表，显示为NULL
```

#### TYPE列

按性能从高至低排列如下：


值 | 含义
-|-|
system | 这是const联接类型的一个特例，当查询的表只有一行时使用
const |	表中有且只有一个匹配的行时使用，如对主键或是唯一索引的查询，这是效率最高的联接方式
eq_ref | 唯一索引或主键索引查询，对应每个索引键，表中只有一条记录与之匹配
ref | 非唯一索引查找，返回匹配某个单独值的所有行
ref_or_null | 类似于ref类型的查询，但是附加了对NULL值列的查询
index_merge | 该联接类型表示使用了索引合并优化方法
range |	索引范围扫描，常见于between、>、<这样的查询条件
index |	FULL index Scan 全索引扫描，同ALL的区别是，遍历的是索引树
ALL | FULL TABLE Scan 全表扫描，这是效率最差的联接方式

#### Extra列

包含MySQL如何执行查询的附加信息

值 | 含义
-|-|
Distinct | 优化distinct操作，在找到第一个匹配的元素后即停止查找
Not exists | 使用not exists来优化查询
Using filesort | 使用额外操作进行排序，通常会出现在order by或group by查询中
Using index | 使用了覆盖索引进行查询
Using temporary | MySQL需要使用临时表来处理查询，常见于排序，子查询，和分组查询
Using where | 需要在MySQL服务器层使用WHERE条件来过滤数据
select tables optimized away | 直接通过索引来获得数据，不用访问表，这种情况通常效率是最高的

#### POSSIBLE_KEYS列

* 指出MySQL能使用哪些索引来优化查询

* 查询列所涉及到的列上的索引都会被列出，但不一定会被使用

#### KEY列

* 查询优化器优化查询实际所使用的索引

* 如果表中没有可用的索引，则显示为NULL

* 如果查询使用了覆盖索引，则该索引仅出现在Key列中

#### KEY_LEN列

显示MySQL索引所使用的字节数，在联合索引中如果有3列，假如3列字段总长度为100个字节，Key_len显示的可能会小于100字节，比如30字节，这就说明在查询过程中没有使用到联合索引的所有列，只是利用到了前面的一列或2列

* 表示索引字段的最大可能长度

* Key_len的长度由字段定义计算而来，并非数据的实际长度

#### Ref列

* 表示当前表在利用Key列记录中的索引进行查询时所用到的列或常量

#### rows列

* 表示MySQL通过索引的统计信息，估算出来的所需读取的行数（关联查询时，显示的是每次嵌套查询时所需要的行数）

* Rows值的大小是个统计抽样结果，并不十分准确

#### Filtered列

* 表示返回结果的行数占需读取行数的百分比

* Filtered列的值越大越好（值越大，表明实际读取的行数与所需要返回的行数越接近）

* Filtered列的值依赖统计信息，所以同样也不是十分准确，只是一个参考值

### 三. 执行计划的限制

* 无法展示存储过程，触发器，UDF对查询的影响

* 无法使用EXPLAIN对存储过程进行分析

* 早期版本的MySQL只支持对SELECT语句进行分析